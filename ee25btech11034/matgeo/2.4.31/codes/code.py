import ctypes
import matplotlib.pyplot as plt
import os

# --- 1. Define a Python class that mirrors the C Point struct ---
class Point(ctypes.Structure):
    _fields_ = [("x", ctypes.c_double),
                ("y", ctypes.c_double)]

# --- 2. Load the compiled shared library ---
# We are specifically using a .so file as requested.
lib_path = './so_main.so'

try:
    # Load the library
    c_lib = ctypes.CDLL(lib_path)
except OSError:
    print(f"Error: Could not find the shared library at '{lib_path}'")
    print("Please compile the C code first. See instructions.")
    exit()

# --- 3. Define the function signatures (argument and return types) ---
# This tells ctypes how to properly call the C functions.

# int checkPerpendicularBisector(Point A, Point P, Point Q)
c_lib.checkPerpendicularBisector.argtypes = [Point, Point, Point]
c_lib.checkPerpendicularBisector.restype = ctypes.c_int

# void generateLinePoints(Point p1, Point p2, int numPoints, Point* out_points)
c_lib.generateLinePoints.argtypes = [Point, Point, ctypes.c_int, ctypes.POINTER(Point)]
c_lib.generateLinePoints.restype = None

# --- 4. Prepare data and call the C functions ---

# Define the points using the ctypes structure
A = Point(2.0, 7.0)
P = Point(6.0, 5.0)
Q = Point(0.0, -4.0)
M = Point((P.x + Q.x) / 2.0, (P.y + Q.y) / 2.0)

# Call the check function and print the result
is_on_bisector = c_lib.checkPerpendicularBisector(A, P, Q)
print("--- Result from C Function ---")
if is_on_bisector:
    print("✅ Point A lies on the perpendicular bisector of PQ.\n")
else:
    print("❌ Point A does NOT lie on the perpendicular bisector of PQ.\n")

# Prepare arrays to receive the points generated by the C function
NUM_POINTS = 11
PointsArray = Point * NUM_POINTS # Create a ctypes array type
pq_points_c = PointsArray()      # Instantiate an array for PQ points
am_points_c = PointsArray()      # Instantiate an array for AM points

# Call the generate function for both line segments
c_lib.generateLinePoints(P, Q, NUM_POINTS, pq_points_c)
c_lib.generateLinePoints(A, M, NUM_POINTS, am_points_c)

# --- 5. Convert ctypes arrays to Python lists for plotting ---
pq_x = [p.x for p in pq_points_c]
pq_y = [p.y for p in pq_points_c]
am_x = [p.x for p in am_points_c]
am_y = [p.y for p in am_points_c]

# --- 6. Plot the results using Matplotlib ---
print("--- Plotting Graph ---")
fig, ax = plt.subplots(figsize=(9, 9))

# Plot the main points
ax.scatter(A.x, A.y, color='red', s=100, label=f'Point A ({A.x}, {A.y})', zorder=5)
ax.scatter(P.x, P.y, color='blue', s=100, label=f'Point P ({P.x}, {P.y})', zorder=5)
ax.scatter(Q.x, Q.y, color='green', s=100, label=f'Point Q ({Q.x}, {Q.y})', zorder=5)
ax.scatter(M.x, M.y, color='purple', s=100, label=f'Midpoint M ({M.x:.1f}, {M.y:.1f})', zorder=5)

# Plot the lines using the data generated by the C function
ax.plot(pq_x, pq_y, 'k-', lw=2, label='Line Segment PQ (from C)')
ax.plot(am_x, am_y, 'r--', lw=2, label='Line Segment AM (from C)')

# Finalize and show the plot
ax.set_title('Geometric Plotting using Python with C Backend', fontsize=16)
ax.set_xlabel('X-axis', fontsize=12)
ax.set_ylabel('Y-axis', fontsize=12)
ax.axhline(0, color='grey', lw=0.5)
ax.axvline(0, color='grey', lw=0.5)
ax.grid(True, linestyle='--', alpha=0.7)
ax.set_aspect('equal', adjustable='box')
ax.legend(fontsize=10)
plt.show()
print("Plot displayed.")
