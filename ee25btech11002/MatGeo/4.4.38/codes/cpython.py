import ctypes
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Load DLL
# Note: The path to the DLL is from your original code.
# Ensure this path is correct on your system.
try:
    np.ctypeslib.ndpointer(dtype=np.float64, flags="C_CONTIGUOUS")
    mylib = ctypes.CDLL(r"D:/Matgeo/4.4.38/codes/mylib.so")
except OSError as e:
    print(f"Failed to load the DLL. Please check the file path and architecture.")
    print(f"Error: {e}")
    exit()

# --- Function prototypes ---
# We define the argument types to ensure data is passed correctly to the C functions.
mylib.midpoint.argtypes = [
    np.ctypeslib.ndpointer(dtype=np.float64, flags="C_CONTIGUOUS"),
    np.ctypeslib.ndpointer(dtype=np.float64, flags="C_CONTIGUOUS"),
    np.ctypeslib.ndpointer(dtype=np.float64, flags="C_CONTIGUOUS"),
    ctypes.c_int
]
mylib.midpoint.restype = None

mylib.compute_line.argtypes = [
    np.ctypeslib.ndpointer(dtype=np.float64, flags="C_CONTIGUOUS"),
    np.ctypeslib.ndpointer(dtype=np.float64, flags="C_CONTIGUOUS"),
    np.ctypeslib.ndpointer(dtype=np.float64, flags="C_CONTIGUOUS"),
    np.ctypeslib.ndpointer(dtype=np.float64, flags="C_CONTIGUOUS"),
    np.ctypeslib.ndpointer(dtype=np.float64, flags="C_CONTIGUOUS"),
    ctypes.c_int
]
mylib.compute_line.restype = None

# --- Input Data based on the problem's geometry ---
A = np.array([2.0, 3.0, 4.0], dtype=np.float64)
B = np.array([4.0, 5.0, 8.0], dtype=np.float64)

p1 = np.array([8.0, -19.0, 10.0], dtype=np.float64)
m1 = np.array([3.0, -16.0, 7.0], dtype=np.float64)

p2 = np.array([15.0, 29.0, 5.0], dtype=np.float64)
m2 = np.array([3.0, 8.0, -5.0], dtype=np.float64)

# --- Calculations and Vector Definitions ---
# Calculate the midpoint h using the C library
h = np.zeros(3, dtype=np.float64)
mylib.midpoint(A, B, h, 3) # h is now [3., 4., 6.]


m_solution_simplified = np.array([2.0, 3.0, 6.0], dtype=np.float64)

# --- Generate Line Points using the C library ---
n = 100

# We create scaling factors to make the lines generated by the C function
# match the visual lengths from your pure Python reference code.
scale_solution = 7.0 / (n / 2.0)
scale_given = 1.5 / (n / 2.0)

# Apply the scaling to our direction vectors
m_solution_scaled = m_solution_simplified * scale_solution
m1_scaled = m1 * scale_given
m2_scaled = m2 * scale_given

# Allocate arrays for the coordinates of each line
x_sol, y_sol, z_sol = [np.zeros(n, dtype=np.float64) for _ in range(3)]
x1, y1, z1 = [np.zeros(n, dtype=np.float64) for _ in range(3)]
x2, y2, z2 = [np.zeros(n, dtype=np.float64) for _ in range(3)]

# Generate the points for each line using the C function
mylib.compute_line(x_sol, y_sol, z_sol, h, m_solution_scaled, n)
mylib.compute_line(x1, y1, z1, p1, m1_scaled, n)
mylib.compute_line(x2, y2, z2, p2, m2_scaled, n)

# --- Plotting ---
fig = plt.figure(figsize=(12, 10))
ax = fig.add_subplot(111, projection="3d")

# Plot the elements
ax.scatter(h[0], h[1], h[2], color='green', s=200, label='Midpoint h (3, 4, 6)', zorder=5)
ax.plot(x1, y1, z1, color='orange', linewidth=2, label='Given Line 1')
ax.plot(x2, y2, z2, color='purple', linewidth=2, label='Given Line 2')
ax.plot(x_sol, y_sol, z_sol, color='red', linewidth=3, label='Required Line (Solution)')

# --- Formatting the plot ---
ax.set_xlabel("X-axis", fontsize=12)
ax.set_ylabel("Y-axis", fontsize=12)
ax.set_zlabel("Z-axis", fontsize=12)
ax.set_title("Visualization of Line Bisecting a Segment and Perpendicular to Two Lines", fontsize=16, pad=20)

# Set axis limits to properly frame the content
ax.set_xlim([-15, 25])
ax.set_ylim([-45, 45])
ax.set_zlim([-40, 50])

ax.legend(loc='upper left')
ax.grid(True)

# Set the aspect ratio to be equal for a true-to-scale representation.
ax.set_box_aspect([1, 1, 1])

plt.show()