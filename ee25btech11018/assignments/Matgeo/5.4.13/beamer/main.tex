\documentclass{beamer}
\usepackage[utf8]{inputenc}

\usetheme{Madrid}
\usecolortheme{default}
\usepackage{amsmath,amssymb,amsfonts,amsthm}
\usepackage{mathtools}
\usepackage{txfonts}
\usepackage{tkz-euclide}
\usepackage{listings}
\usepackage{adjustbox}
\usepackage{array}
\usepackage{tabularx}
\usepackage{gvv}
\usepackage{lmodern}
\usepackage{circuitikz}
\usepackage{tikz}
\usepackage{graphicx}
\setbeamertemplate{page number in head/foot}[totalframenumber]
\usepackage[T1]{fontenc}
\usepackage{tcolorbox}
\tcbuselibrary{minted,breakable,xparse,skins}

\definecolor{bg}{gray}{0.95}
\DeclareTCBListing{mintedbox}{O{}m!O{}}{%
  breakable=true,
  listing engine=minted,
  listing only,
  minted language=#2,
  minted style=default,
  minted options={%
    linenos,
    gobble=0,
    breaklines=true,
    breakafter=,,
    fontsize=\small,
    numbersep=8pt,
    #1},
  boxsep=0pt,
  left skip=0pt,
  right skip=0pt,
  left=25pt,
  right=0pt,
  top=3pt,
  bottom=3pt,
  arc=5pt,
  leftrule=0pt,
  rightrule=0pt,
  bottomrule=2pt,
  toprule=2pt,
  colback=bg,
  colframe=orange!70,
  enhanced,
  overlay={%
    \begin{tcbclipinterior}
    \fill[orange!20!white] (frame.south west) rectangle ([xshift=20pt]frame.north west);
    \end{tcbclipinterior}},
  #3,
}

% Code style
\lstset{
    language=C,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    stringstyle=\color{orange},
    commentstyle=\color{green!60!black},
    numbers=left,
    numberstyle=\tiny\color{gray},
    breaklines=true,
    showstringspaces=false,
}

% Title info
\title %optional
{5.4.13}
\date{October 4, 2025}
\author % (optional)
{EE25BTECH11018 - Darisy Sreetej}

\begin{document}

\frame{\titlepage}

\begin{frame}{Question}
Using elementary transformations, find the inverse of the following matrix. 
\begin{align*}
\myvec{1&3\\2&7}
\end{align*}
\end{frame}
\begin{frame}{Solution}
Given  
\begin{align}
\vec{M}=\myvec{1&3\\2&7}
\end{align}
Let $\vec{M}^{-1}$ be the inverse of $\vec{M}$.Then
\begin{align}
    \vec{M}\vec{M}^{-1}=\vec{I}
\end{align}
Augmented matrix of $\augvec{1}{1}{\vec{M} & \vec{I}}$ is given by
\begin{align}
    \augvec{2}{2}{1& 3 & 1 & 0 \\ 2 & 7 & 0 & 1} 
    \xrightarrow{R_2 \rightarrow R_2 - 2R_1}
    \augvec{2}{2}{1 & 3 & 1 & 0 \\ 0 & 1 & -2 & 1}
    \xrightarrow{R_1 \rightarrow R_1 - 3R_2}
    \augvec{2}{2}{1 & 0 & 7 & -3 \\ 0 & 1 & -2 & 1} 
    \end{align}
Hence the inverse of the matrix $\myvec{1&3\\2&7}$ is \myvec{7&-3\\-2&1}
\end{frame}
\begin{frame}[fragile]
\frametitle{C code}
    \begin{lstlisting}[language=C]
#include <stdio.h>

#define N 2  // Matrix size

void inverse(double A[N][N], double inv[N][N]) {
    double aug[N][2*N];

    // Forming augmented matrix [A | I]
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            aug[i][j] = A[i][j];
            aug[i][j + N] = (i == j) ? 1 : 0;
        }
    }

\end{lstlisting}
\end{frame}
\begin{frame}[fragile]
    \frametitle{C Code }
    \begin{lstlisting}[language=C]
      // Applying Gaussâ€“Jordan elimination
    for (int i = 0; i < N; i++) {
        double pivot = aug[i][i];
        for (int j = 0; j < 2*N; j++) {
            aug[i][j] /= pivot;  // Make pivot element = 1
        }

        for (int k = 0; k < N; k++) {
            if (k != i) {
                double factor = aug[k][i];
                for (int j = 0; j < 2*N; j++) {
                    aug[k][j] -= factor * aug[i][j];
                }
            }
        }
    }
     \end{lstlisting}
\end{frame}
\begin{frame}[fragile]
    \frametitle{C Code }
    \begin{lstlisting}[language=C]
    // Obtaining inverse matrix
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            inv[i][j] = aug[i][j + N];
        }
    }
}

    \end{lstlisting}
\end{frame}
\begin{frame}[fragile]
    \frametitle{Python + C code}

    \begin{lstlisting}[language=Python]
import ctypes
import numpy as np
import sympy as sp

# Load the compiled shared library (.so file)
lib = ctypes.CDLL("./inverse_matrix.so")

# Define the argument types for the inverse function
lib.inverse.argtypes = [
    ctypes.POINTER((ctypes.c_double * 2) * 2),
    ctypes.POINTER((ctypes.c_double * 2) * 2)
]
# Define the 2x2 input matrix A
A = np.array([[1, 3],
              [2, 7]], dtype=np.double)

    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Python + C code}

    \begin{lstlisting}[language=Python]

# Prepare an empty matrix for the inverse
inv = np.zeros((2, 2), dtype=np.double)

# Call the C function: inverse(A, inv)
lib.inverse(
    A.ctypes.data_as(ctypes.POINTER((ctypes.c_double * 2) * 2)),
    inv.ctypes.data_as(ctypes.POINTER((ctypes.c_double * 2) * 2))
)

# Convert the result to a Sympy Matrix for clean display
inverse = sp.Matrix(inv)

print("Inverse of the matrix:")
sp.pprint(inverse)

\end{lstlisting}
\end{frame}
\begin{frame}[fragile]
    \frametitle{Python code}
    \begin{lstlisting}[language=Python]
import sympy as sp

# Define the matrix
A = sp.Matrix([[1, 3],
               [2, 7]])

# Find the inverse using Sympy
A_inv = A.inv()

# Display the result neatly
print("Inverse of the matrix:")
sp.pprint(A_inv)

    \end{lstlisting}
\end{frame}
\end{document}
