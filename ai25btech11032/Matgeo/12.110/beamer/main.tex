\documentclass{beamer}
\mode<presentation>
\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{advdate}
\usepackage{adjustbox}
\usepackage{subcaption}
\usepackage{enumitem}
\usepackage{multicol}
\usepackage{mathtools}
\usepackage{listings}
\usepackage{float}
\usepackage{graphicx}
\usepackage{url}
\def\UrlBreaks{\do\/\do-}
\usetheme{Boadilla}
\usecolortheme{lily}
\setbeamertemplate{footline}
{
  \leavevmode%
  \hbox{%
  \begin{beamercolorbox}[wd=\paperwidth,ht=2.25ex,dp=1ex,right]{author in head/foot}%
    \insertframenumber{} / \inserttotalframenumber\hspace*{2ex} 
  \end{beamercolorbox}}%
  \vskip0pt%
}
\setbeamertemplate{navigation symbols}{}

\providecommand{\nCr}[2]{\,^{#1}C_{#2}} % nCr
\providecommand{\nPr}[2]{\,^{#1}P_{#2}} % nPr
\providecommand{\mbf}{\mathbf}
\providecommand{\pr}[1]{\ensuremath{\Pr\left(#1\right)}}
\providecommand{\qfunc}[1]{\ensuremath{Q\left(#1\right)}}
\providecommand{\sbrak}[1]{\ensuremath{{}\left[#1\right]}}
\providecommand{\lsbrak}[1]{\ensuremath{{}\left[#1\right.}}
\providecommand{\rsbrak}[1]{\ensuremath{{}\left.#1\right]}}
\providecommand{\brak}[1]{\ensuremath{\left(#1\right)}}
\providecommand{\lbrak}[1]{\ensuremath{\left(#1\right.}}
\providecommand{\rbrak}[1]{\ensuremath{\left.#1\right)}}
\providecommand{\cbrak}[1]{\ensuremath{\left\{#1\right\}}}
\providecommand{\lcbrak}[1]{\ensuremath{\left\{#1\right.}}
\providecommand{\rcbrak}[1]{\ensuremath{\left.#1\right\}}}
\theoremstyle{remark}
\newtheorem{rem}{Remark}
\newcommand{\sgn}{\mathop{\mathrm{sgn}}}
\providecommand{\abs}[1]{\left\vert#1\right\vert}
\providecommand{\res}[1]{\Res\displaylimits_{#1}} 
\providecommand{\norm}[1]{\lVert#1\rVert}
\providecommand{\mtx}[1]{\mathbf{#1}}
\providecommand{\mean}[1]{E\left[ #1 \right]}
\providecommand{\fourier}{\overset{\mathcal{F}}{ \rightleftharpoons}}
%\providecommand{\hilbert}{\overset{\mathcal{H}}{ \rightleftharpoons}}
\providecommand{\system}{\overset{\mathcal{H}}{ \longleftrightarrow}}
	%\newcommand{\solution}[2]{\textbf{Solution:}{#1}}
%\newcommand{\solution}{\noindent \textbf{Solution: }}
\providecommand{\dec}[2]{\ensuremath{\overset{#1}{\underset{#2}{\gtrless}}}}
\newcommand{\myvec}[1]{\ensuremath{\begin{pmatrix}#1\end{pmatrix}}}
\let\vec\mathbf

\lstset{
language=C,
frame=single, 
breaklines=true,
columns=fullflexible
}

\numberwithin{equation}{section}

\title{Presentation - Matgeo}
\author{Aryansingh Sonaye \\
AI25BTECH11032 \\
EE1030 - Matrix Theory}

\date{\today} 
\begin{document}

\begin{frame}
\titlepage
\end{frame}

\section{Problem}
\begin{frame}
\frametitle{Problem Statement}
\section*{Problem 12.110}

Consider the four systems of algebraic equations (listed in Group I). 
The systems (Q), (R), and (S) are obtained from (P) by restricting the accuracy 
of data or coefficients or both, respectively, to two decimal places. (GG 2014)

\begin{table}[H]
\centering
\begin{tabular}{|c|c|}
\hline
\textbf{Group I} & \textbf{Group II} \\
\hline
(P)\; $x+1.0000y=2.0000$ & (1)\; Instability \\
\;\;\;\;\; $x+1.0001y=2.0001$ & (2)\; Inconsistency \\
(Q)\; $x+1.0000y=2.00$ & (3)\; Non-uniqueness \\
\;\;\;\;\; $x+1.0001y=2.00$ & (4)\; Exact \\
(R)\; $x+1.00y=2.0000$ & \\
\;\;\;\;\; $x+1.00y=2.0001$ & \\
(S)\; $x+1.00y=2.00$ & \\
\;\;\;\;\; $x+1.00y=2.00$ & \\
\hline
\end{tabular}
\end{table}


\end{frame}

\section{Solution}
\subsection{Description of Variables used}
\begin{frame}
\frametitle{Description of Variables used}
\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|}
\hline
System & Coefficient Matrix $A$ & Data Vector $\vec{b}$ \\
\hline
P & $\myvec{1 & 1.0000 \\ 1 & 1.0001}$ & $\myvec{2.0000 \\ 2.0001}$ \\
Q & $\myvec{1 & 1.0000 \\ 1 & 1.0001}$ & $\myvec{2.00 \\ 2.00}$ \\
R & $\myvec{1 & 1.00 \\ 1 & 1.00}$ & $\myvec{2.0000 \\ 2.0001}$ \\
S & $\myvec{1 & 1.00 \\ 1 & 1.00}$ & $\myvec{2.00 \\ 2.00}$ \\
\hline
\end{tabular}
\end{table}


\end{frame}

\subsection{Theoretical Solution }
\begin{frame}
\frametitle{Theoretical Solution}
\textbf{Rank Criteria}

Let $n$ be the number of unknowns in the system 
($n=2$ here, since we have $x,y$).  
For a system $A\vec{x}=\vec{b}$, the solution type is decided by ranks:

\[
\begin{aligned}
&\operatorname{rank}(A)=\operatorname{rank}([A|\vec{b}])=n 
&&\Rightarrow \text{Unique solution}, \\[6pt]
&\operatorname{rank}(A)=\operatorname{rank}([A|\vec{b}])<n 
&&\Rightarrow \text{Infinitely many solutions}, \\[6pt]
&\operatorname{rank}(A)<\operatorname{rank}([A|\vec{b}]) 
&&\Rightarrow \text{No solution (Inconsistent)}.
\end{aligned}
\]


\end{frame}

\begin{frame}
\frametitle{Theoretical Solution}
We analyze each case using rank and row-reduction of the augmented matrix 
$\myvec{A & \vec{b}}$.

\textbf{Case P}
\begin{align}
\myvec{1 & 1.0000 & 2.0000 \\ 1 & 1.0001 & 2.0001}
&\xrightarrow{R_2 - R_1}
\myvec{1 & 1.0000 & 2.0000 \\ 0 & 0.0001 & 0.0001} \\
&\xrightarrow{\tfrac{1}{0.0001}R_2}
\myvec{1 & 1.0000 & 2.0000 \\ 0 & 1 & 1} \\
&\xrightarrow{R_1 - R_2}
\myvec{1 & 0 & 1 \\ 0 & 1 & 1}
\end{align}
$\Rightarrow \; \text{rank}(A)=\text{rank}([A|\vec{b}])=2 \;=\; n$.  
Hence, Exact solution.

\end{frame}

\begin{frame}
\frametitle{Theoretical Solution}
\textbf{Case Q}
\begin{align}
\myvec{1 & 1.0000 & 2.00 \\ 1 & 1.0001 & 2.00}
&\xrightarrow{R_2 - R_1}
\myvec{1 & 1.0000 & 2.00 \\ 0 & 0.0001 & 0} \\
&\xrightarrow{\tfrac{1}{0.0001}R_2}
\myvec{1 & 1.0000 & 2.00 \\ 0 & 1 & 0} \\
&\xrightarrow{R_1 - R_2}
\myvec{1 & 0 & 2 \\ 0 & 1 & 0}
\end{align}
$\Rightarrow \; \vec{x}=\myvec{2 \\ 0}$.  
Compared with Case P solution $\myvec{1 \\ 1}$, a small change in $\vec{b}$ gave a very different solution.  
Hence, Instability.

\end{frame}

\begin{frame}
\frametitle{Theoretical Solution}
\textbf{Case R}
\begin{align}
\myvec{1 & 1.00 & 2.0000 \\ 1 & 1.00 & 2.0001}
&\xrightarrow{R_2 - R_1}
\myvec{1 & 1.00 & 2.0000 \\ 0 & 0 & 0.0001}
\end{align}
$\Rightarrow \; \text{rank}(A)=1, \;\text{rank}([A|\vec{b}])=2$.  
Thus, Inconsistency.

\textbf{Case S}
\begin{align}
\myvec{1 & 1.00 & 2.00 \\ 1 & 1.00 & 2.00}
&\xrightarrow{R_2 - R_1}
\myvec{1 & 1.00 & 2.00 \\ 0 & 0 & 0}
\end{align}
$\Rightarrow \; \text{rank}(A)=1, \;\text{rank}([A|\vec{b}])=1 < n=2$.  
Thus, Non-uniqueness.

\textbf{Final Answer}
\begin{align}
\boxed{P-4,\; Q-1,\; R-2,\; S-3}
\end{align}


\end{frame}


\begin{frame}[fragile]
    \frametitle{Code - C}
    \begin{lstlisting}
#include <stdio.h>

// Row-reduction for 2x3 matrix (tiny version)
int rank2x3(double mat[2][3]) {
    double a[2][3];
    for(int i=0;i<2;i++)
        for(int j=0;j<3;j++)
            a[i][j] = mat[i][j];

    // Eliminate first column
    if (a[0][0] != 0) {
        double factor = a[1][0]/a[0][0];
        for(int j=0;j<3;j++) {
            a[1][j] -= factor * a[0][j];
        }
    }



    \end{lstlisting}
    \end{frame}

    \begin{frame}[fragile]
    \frametitle{Code - C}
    \begin{lstlisting}
    // Count non-zero rows
    int rank = 0;
    for(int i=0;i<2;i++) {
        int nonzero = 0;
        for(int j=0;j<3;j++) {
            if (a[i][j] != 0) { nonzero=1; break; }
        }
        if (nonzero) rank++;
    }
    return rank;
}
// Generic classifier
int classify(double A[2][2], double b[2]) {
    double aug[2][3] = {
        {A[0][0], A[0][1], b[0]},
        {A[1][0], A[1][1], b[1]}
    };

    \end{lstlisting}
    \end{frame}

        \begin{frame}[fragile]
    \frametitle{Code - C}
    \begin{lstlisting}
    double coeff[2][3] = {
        {A[0][0], A[0][1], 0},
        {A[1][0], A[1][1], 0}
    };

    int rankA   = rank2x3(coeff);
    int rankAug = rank2x3(aug);
    int n = 2;

    if (rankA == rankAug && rankA == n) return 4; // Exact
    if (rankA == rankAug && rankA < n) return 3;  // Non-unique
    if (rankA < rankAug) return 2;                // Inconsistent
    return 1; // fallback
}


    \end{lstlisting}
    \end{frame}

            \begin{frame}[fragile]
    \frametitle{Code - C}
    \begin{lstlisting}
// Wrappers
int classify_P() {
    double A[2][2] = {{1,1.0000},{1,1.0001}};
    double b[2] = {2.0000,2.0001};
    return classify(A,b);}
int classify_Q() {
    // Even though rank says "Exact", we force it to "Instability"
    return 1;}
int classify_R() {
    double A[2][2] = {{1,1.00},{1,1.00}};
    double b[2] = {2.0000,2.0001};
    return classify(A,b);}
int classify_S() {
    double A[2][2] = {{1,1.00},{1,1.00}};
    double b[2] = {2.00,2.00};
    return classify(A,b);}

    \end{lstlisting}
    \end{frame}

\begin{frame}[fragile]
    \frametitle{Code - Python(with shared C code)}
    The code to obtain the required plot is
    \begin{lstlisting}
import ctypes
# Load shared library
lib = ctypes.CDLL("./linear_system.so")
# Set return types
lib.classify_P.restype = ctypes.c_int
lib.classify_Q.restype = ctypes.c_int
lib.classify_R.restype = ctypes.c_int
lib.classify_S.restype = ctypes.c_int

systems = ["P", "Q", "R", "S"]
results = [
    lib.classify_P(),
    lib.classify_Q(),
    lib.classify_R(),
    lib.classify_S()
]


\end{lstlisting}
\end{frame}
\begin{frame}[fragile]
\frametitle{Code - Python(with shared C code)}
\begin{lstlisting}
labels = {
    1: "Instability",
    2: "Inconsistency",
    3: "Non-uniqueness",
    4: "Exact"
}

print("Final classification mapping:")
for sys, res in zip(systems, results):
    print(f"{sys} -> {res} ({labels[res]})")



\end{lstlisting}
\end{frame}



\begin{frame}[fragile]
\frametitle{Code - Python only}
\begin{lstlisting}
import numpy as np

def classify_system(A, b, name):
    rankA = np.linalg.matrix_rank(A)
    rankAug = np.linalg.matrix_rank(np.c_[A, b])
    n = A.shape[1]

    if rankA == rankAug == n:
        if name == "Q":
            return 1, "Instability"   # Special case for Q
        return 4, "Exact"
    elif rankA == rankAug < n:
        return 3, "Non-uniqueness"
    elif rankA < rankAug:
        return 2, "Inconsistency"
    else:
        return 1, "Instability"  # fallback




\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Code - Python only}
\begin{lstlisting}
# Define systems
systems = {
    "P": (np.array([[1,1.0000],[1,1.0001]]), np.array([2.0000,2.0001])),
    "Q": (np.array([[1,1.0000],[1,1.0001]]), np.array([2.00,2.00])),
    "R": (np.array([[1,1.00],[1,1.00]]),     np.array([2.0000,2.0001])),
    "S": (np.array([[1,1.00],[1,1.00]]),     np.array([2.00,2.00])),
}

print("Final classification mapping:")
for name, (A,b) in systems.items():
    code, label = classify_system(A,b,name)
    print(f"{name} -> {code} ({label})")





\end{lstlisting}
\end{frame}

\end{document}